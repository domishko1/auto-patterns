## Паттерны проектирования в автоматизации тестирования

### Структурные паттерны
Задача структурных паттернов сводится к структурированию кода тестов — чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью. 
#### Page Object
Паттерн помогает сохранить логическую структуру приложения; разделить технических деталей и логику тестов; уменьшить дублирование кода.
#### Fluent/Chain of invocations
Паттерн помогает понять, можно ли вызвать какой-либо метод на этой странице (page).
При использовании этого паттерна, когда нужно сделать следующее действие, будет появляться автоподсказка доступных действий.

В PageObjects классах или других местах, где можно применить этот паттерн, используется возвращаемое значение, которое может быть this или любой другой объект, с которым дальше можно продолжить работу.

#### Page Element/Composite List of Items Link Menu Panel Checkbox
Любое приложение состоит из повторяющихся элементов, к которым вы снова и снова пишете логику ваших в ваших тестах.
Такие части приложения можно выделять в отдельные widget-объекты.
#### Loadable Component
Когда открывается страница и необходимо работать с каким-либо элементом этой страницы, по-хорошему следует дождаться и убедиться, что эта страница логически загружена.

И для того, чтобы избежать следующего: что-то сделали – wait, что-то сделали – wait, можно каждую страницу, которая используется, наследовать от loadable component и перегрузить метод из loaded, благодаря чему "скроется" это ожидание.
В этом случае будет инкапсулирована логика в одном месте – если одна и та же страница будет в пяти местах вызываться и нигде больше этот wait руками писать не придется.

#### Strategy
Паттерн используется, если нужно иметь несколько реализаций одного и того же – либо последовательностей, либо действий. Можно подставлять туда эту реализацию в зависимости от контекста.

### Паттерны данных
Суть таких паттернов - как можно дальше оттащить данные и управление данными от тестовой логики, для того, чтобы убрать количество так называемого boilerplate code – мусорного кода, засоряющего тесты.
Благодаря этому логика станет еще более прозрачной, ее будет легче поддерживать.

#### Value Object
Паттерн используется, если есть несколько объектов, объединенных между собой логически, например, есть registerUser, и мы передаем туда пять параметров – имя, фамилию, возраст, роль и прочее.
После того как класс создается, его нельзя изменить, потому что в этом его задача, он служит для передачи данных из точки А в точку Б, а не для того, чтобы быть модифицируемым или нести сторонние эффекты.

#### Builder
Предположим, у нас есть большой объект, и этот объект может быть сконфигурировано совершенно по-разному. 

Можно пойти первым способом и добавить столько конструкторов, сколько вариаций у вас есть, и каждый раз, когда вы встречаетесь с новой вариацией, вы можете добавлять новый конструктор.

Чтобы упростить это, сделать конструкторы более понятными и добавить возможность автоподсказки того, что еще можно сконфигурировать, используется паттерн Builder.
#### Assert Object/Matchers
У нас есть классический подход – мы вытащили пользователей и хотим сделать на них какие-то проверки.

Предлагается делать это таким образом: во-первых, выделяются группы ассертов, для этого можно использовать либо создание отдельных классов (в данном случае это UserAssert), который делает все возможные ассерты с юзерами, и для того, чтобы это выглядело красиво, делается либо статический метод на самом UserAssert, который говорит assertThat и таким образом возвращает вам этот ассерт, на котором вы можете делать свои дальнейшие проверки.

#### Data Registry
Предположим, мы в тестах начинаем использовать данные, и для того, чтобы они были независимы друг от друга, пытаемся каким-то образом отвязать их друг от друга, но в результате можем прийти к тому, что получаются зависимые тесты, которые будут «знать» о логике друг друга.

Подход Data Registry позволяет генерировать уникальные данные и следить за их уникальностью. 
В данном случае используется простейший подход: спрашиваем «дай нам уникального пользователя» и используем статический инкрементальный многопоточный счетчик, который постоянно инкрементирует его на единичку, тем самым гарантируя уникальных юзеров.

#### Object Pool/Flyweight
Паттерн решает проблемы с объектами или наборами объектов, которые тяжеловесны в создании. Вместо того, чтобы создавать их каждый раз, мы берём их, пользуемся, и после этого они возвращаются в тот же Pool, откуда мы их взяли.

#### Data Provider
Паттерн используется, чтобы одна и та же тестовая логика выполнялась с разными данными, для этого вы загружаете свои данные из какого-либо внешнего источника (в данном случае xls), либо из CSV, либо подтягиваете с какого-то сервиса, либо они у вас вшиты прямо здесь.

### Технические паттерны
Технические паттерны служат для того, чтобы вынести технические аспекты отдельно от тестовой логики, и зачастую для обеспечения дополнительного низкоуровневого контроля над технической частью.

#### Decorator
Используется, если проводиться работа с какими-либо техническими драйверами (web-драйвер или какой-либо еще) — и нужно добавить к нему, например, логирование или кэширование, или что-то еще. 
Но при этом тесты не должны об этом знать. В этом случае сама логика теста остается прежней — меняется только техническая реализация.

Поэтому используется «принципом капусты» — заворачивая «листок в листок в листок», в итоге получается концепция «драйвер в драйвере в драйвере», о которой тесты не догадываются: они как работали с интерфейсом драйвера, так и продолжают.

#### Proxy
Паттерн, позволяющий вмешаться в процесс между вами и ещё кем-то, и внедрить туда любую логику, не затрагивая ни вас, ни его.

Этот паттерн может быть полезен тогда, когда, например, вы хотите добавить логирование, вы хотите включить или отключить что-то, вы хотите управлять дополнительно какими-то ресурсами.
#� �a�u�t�o�-�p�a�t�t�e�r�n�s�
�
�#� �a�u�t�o�-�p�a�t�t�e�r�n�s�
�
�
